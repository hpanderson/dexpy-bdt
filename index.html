
<html>
<head>
		<meta charset="utf-8">
		<title>dexpy demo</title>
    <link rel="stylesheet" href="reveal.js/css/reveal.css">
    <link rel="stylesheet" href="reveal.js/css/theme/league.css">
		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
</head>
<body>
<div class="reveal">
<div class="slides">

<section data-markdown>
	<textarea data-template>

## Design of Experiments in Python

Hank Anderson

[hank@statease.com](mailto:hank@statease.com)<br>
[https://github.com/hpanderson/dexpy-bdt](https://github.com/hpanderson/dexpy-bdt)

	</textarea>
</section>

<section data-markdown>
	<textarea data-template>

## Agenda

* What is Design of Experiments?
* Design an experiment with <strong>dexpy</strong> to improve the office coffee
* Measure the power of our experiment
* Model the taste test results using <strong>statsmodels</strong>
* Visualize the data with <strong>seaborn</strong> and <strong>matplotlib</strong> to find the best pot of coffee

	</textarea>
</section>

<section>
  <section>

    <h2>What is Design of Experiments (DoE)?</h2>
    <p>A systematic series of tests, in which purposeful changes are made to input factors, so that you may identify causes for significant changes in the output responses.</p>
    <!--<p>NIST has a <a href="http://www.itl.nist.gov/div898/handbook/pri/section1/pri1.htm">nice primer on DOE</a>.</p>-->
    <img src="img/doe_digraph.svg">

  </section>

  <section>

    <h2>History of DOE</h2>
		<img style="float: left;" src="img/fisher.jpg">
    R.A. Fisher<br>
    <ul>
      <li>1919 - Rothamsted Experimental Station</li>
      <li>ANOVA, F-test, null hypothesis</li>
      <li>1935 - The Design of Experiments</li>
      <li>"The Lady Tasting Tea" experiment</li>
    </ul>

  </section>

</section>

<section>
  <section>
    <h1>"Purposeful Changes"</h1>
    <p class="fragment">Correlation != Causation</p>
    <p class="fragment">
      <img src="img/correlation.png"><br>
      <small style="font-size:8;"><a href="http://tylervigen.com/view_correlation?id=97">source</a></small>
    </p>
  </section>
  <section>
    <img src="img/tinfoil_coffee.png">
  </section>
</section>

<section>
  <section data-markdown>
    <textarea data-template>
## What Is It For?

* **Screening Experiments** - Determining which inputs to your system are important
* **Modeling a Process** - Gain a better understanding of your system
* **Optimization** - Find the combination of inputs that results in a better output
* **Robustness** - Find a combination of inputs that produces a consistent result
    </textarea>
  </section>

  <section data-markdown>
    <textarea data-template>
## Examples
* A/B testing of a website
* Allocating marketing budget resources
* Microwave popcorn
    </textarea>
  </section>
</section>

<section data-markdown>
  <textarea data-template>
## DoE in Python: dexpy

* Based on Design-Expert<sup>&reg;</sup> software, a package for design and analysis of industrial experiments
* Apache2 licensed, pure python (for now), available on pypi
* Other alternatives are:
   * [pyDOE](https://github.com/tisimst/pyDOE) (not actively maintained)
   * R [???](https://cran.r-project.org/web/views/ExperimentalDesign.html)
   * [SciDOE](https://forge.scilab.org/index.php/p/scidoe/)
   * [gosset](http://neilsloane.com/gosset/)
   * Proprietary software ($$$) - [Design-Expert](https://www.statease.com), [JMP](https://www.jmp.com), [Minitab](https://www.minitab.com)
  </textarea>
</section>

<section>
	<section data-markdown>
		<textarea data-template>
## Motivating Example: Better Office Coffee

 * Current coffee is subpar ("disgusting and unacceptable")
 * Need to answer the following questions via experimentation:
  * What coffee beans to use?
  * How much coffee to use?
  * How to grind the coffee?
		</textarea>
	</section>

	<section data-markdown>
		<textarea data-template>
## Motivating Example: Better Office Coffee

 * 5 input factors
  * Amount of Coffee (2.5 to 4.0 oz.)
  * Grind size (8-10mm)
  * Brew time (3.5 to 4.5 minutes)
  * Grind Type (burr vs blade)
  * Coffee beans (light vs dark)
 * 1 response: Average overall liking by a panel of 5 office coffee addicts
  * Each taster rates the coffee from 1-9
 * Maximum of 3 taste tests a day, for liability reasons
		</textarea>
	</section>
</section>

<section>
	<section>

		<h3>One Factor at a Time Experimentation</h3>

		<ul>
			<li>Hold all inputs constant, then change one at a time</li>
			<li>Cannot detect interactions, e.g. grind size and amount of coffee have a synergistic relationship</li>
			<li>Inefficient</li>
    </ul>
  </section>

  <section>
    <img src="img/ofat.svg">
	</section>

  <section>
    <img src="img/ofat_3d.svg">
	</section>
</section>

<section>
  <section data-markdown>
    <textarea data-template>
## Factorial Design

* Change multiple inputs at once
* Reveals interactions
* Maximizes information with minimum runs
    </textarea>
  </section>
  <section>
    <img src="img/factorial.svg">
  </section>
  <section>
    <img src="img/factorial_3d.svg">
  </section>
</section>

<section>
  <h2>Statistical Power</h2>

  <p>The probability that a design will detect an active effect.</p>

  <table>
    <thead>
      <tr>
        <th>Effect?</th>
        <th>Retain H<sub>0</sub></th>
        <th>Reject H<sub>0</sub></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>No</strong></td>
        <td>OK</td>
        <td>Type I Error</td>
      </tr>
      <tr>
        <td><strong>Yes</strong></td>
        <td>Type II Error</td>
        <td>OK</td>
      </tr>
    </tbody>
  </table>

  <p>Power is expressed as a probability to detect an effect of size Δ, given noise σ. This is typically given as a delta to sigma ratio Δ/σ. Power is a function of the signal to noise ratio, as well as the number and layout of experiments in the design.</p>
</section>

<section>
  <section>
    <h2>Power Example</h2>
    <p>We taste test 25 pots of coffee with light beans, and 25 pots with dark
    beans. There is a variance of 1.5 taste rating from pot to pot.</p>
    <p>If we expect a 0.5 change in the taste rating when going from light to dark,
    what is the likelihood we would detect it?</p>
  </section>
  <section>
    <img src="img/power_50.svg"><br>
    (Power: <span class="fragment highlight-red">37.86%</span>)
    <br>
    <p style="font-size: 10;">Note: this assumes that we reject H<sub>0</sub> at p <= 0.05</p>
  </section>
</section>

<section>
  <section>
    <h2>Power Example - Increase Delta</h2>
    <p>
      What if we don't care about a taste increase of 0.5? That's not that much better
      than the current coffee, after all. Instead, if we say we only care about a change
      in rating above 2, what is the likelihood we would detect such a change?
    </p>
  </section>
  <section>
    <img src="img/power_50_2.svg"><br>
      (Power: <span class="fragment highlight-green">99.99983%</span>)
  </section>
</section>

<section>
  <section>
    <h2>Power Example - Decrease Noise</h2>
    <p>
      Instead of lowering our standards for our noisy taste ratings, instead
      we could bring in expert testers who have a much more discerning palate.
      These tasters decrease the taste rating variability from 1.5 to 0.75.
    </p>
  </section>
  <section>
    <img src="img/power_50_3.svg"><br>
      (Power: <span class="fragment highlight-green">91%</span>)
  </section>
</section>

<section>
  <section>
    <h2>Power Example - Increase Runs</h2>
    <p>
      If expert testers are too expensive, and we are unwilling to compromise
      our standards, then the only remaining option is to change the experimental
      deisgn. In this toy example, there isn't much we can do other than increase
      the number of pots of coffee from 50 to 200.
    </p>
  </section>
  <section>
    <img src="img/power_50_4.svg"><br>
      (Power: <span class="fragment highlight-green">91.39%</span>)
    <p>
      For more complicated designs changing the structure of the design
      can also increase power.
    </p>
  </section>
</section>

<section>
  <section>
    <h2>Calculating Power with dexpy: OFAT</h2>

    <pre>
      <code data-trim data-noescape>
base_point = [-1, -1, -1, -1, -1]
ofat_points = [base_point]

for i in range(0, 5):
    new_point = base_point[:]
    new_point[i] = 1
    ofat_points.append(new_point)

ofat_df = pd.DataFrame(ofat_points*5,
                       columns=['amount',
                                'grind_size',
                                'brew_time',
                                'grind_type',
                                'beans'])
model = ' + '.join(ofat_df.columns)
ofat_power = dexpy.power.f_power('+'.join(ofat_df.columns),
                                 ofat_df, 2.0, 0.05)
      </code>
    </pre>
  </section>
  <section data-markdown>
    <textarea data-template>
30 total runs, with a signal to noise ratio of 2.

||Power|
|---|---|
|amount|85.85%|
|grind_size|85.85%|
|brew_time|85.85%|
|grind_type|85.85%|
|beans|85.85%|
    </textarea>
  </section>
</section>

<section>
  <section>
    <h2>Calculating Power with dexpy: Factorial</h2>
    <pre>
      <code data-trim data-noescape>
full_design = dexpy.factorial.build_factorial(5, 2**5)
full_design.columns = ['amount',
                       'grind_size',
                       'brew_time',
                       'grind_type',
                       'beans']
model = ' + '.join(full_design.columns)
factorial_power = dexpy.power.f_power(model, full_design, 2.0, 0.05)
      </code>
    </pre>
  </section>

  <section data-markdown>
    <textarea data-template>
32 total runs, with a signal to noise ratio of 2.

||Power|
|---|---|
|amount|99.97%|
|grind_size|99.97%|
|brew_time|99.97%|
|grind_type|99.97%|
|beans|99.97%|
    </textarea>
  </section>
</section>

<section>
  <section data-markdown>
    <textarea data-template>
## Fractional Factorial

* Coffee experiment is 2<sup>5</sup> runs (32)
* We want to add 4 center point runs to check for curvature
* Total runs = 36, 3 per day if all testers are in the office
* Estimate experiment will take a month
    </textarea>
  </section>

  <section data-markdown>
    <textarea data-template>
## Fractional Factorial
* Power for the experiment is > 99%
* Full factorial is overkill
* Instead run 2<sup>5-1</sup> experiments, a "half fraction"
    </textarea>
  </section>
</section>

<section>
  <section>
    <h2>Fractional Factorial</h2>

    <pre>
      <code data-trim data-noescape>
coffee_design = dexpy.factorial.build_factorial(5, 2**(5-1))
coffee_design.columns = ['amount',
                         'grind_size',
                         'brew_time',
                         'grind_type',
                         'beans']
model = ' + '.join(coffee_design.columns)
fractional_power = dexpy.power.f_power(model, coffee_design, 2.0, 0.05)
			</code>
		</pre>
	</section>
  <section>
    <table style="font-size: 16;">
      <thead>
        <tr>
          <th></th>
          <th>amount</th>
          <th>grind_size</th>
          <th>brew_time</th>
          <th>grind_type</th>
          <th>beans</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>0</th>
          <td>2.5</td>
          <td>8</td>
          <td>3.5</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>1</th>
          <td>2.5</td>
          <td>8</td>
          <td>3.5</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>2</th>
          <td>2.5</td>
          <td>8</td>
          <td>4.5</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>3</th>
          <td>2.5</td>
          <td>8</td>
          <td>4.5</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>4</th>
          <td>2.5</td>
          <td>10</td>
          <td>3.5</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>5</th>
          <td>2.5</td>
          <td>10</td>
          <td>3.5</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>6</th>
          <td>2.5</td>
          <td>10</td>
          <td>4.5</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>7</th>
          <td>2.5</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>8</th>
          <td>4</td>
          <td>8</td>
          <td>3.5</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>9</th>
          <td>4</td>
          <td>8</td>
          <td>3.5</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>10</th>
          <td>4</td>
          <td>8</td>
          <td>4.5</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>11</th>
          <td>4</td>
          <td>8</td>
          <td>4.5</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>12</th>
          <td>4</td>
          <td>10</td>
          <td>3.5</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>13</th>
          <td>4</td>
          <td>10</td>
          <td>3.5</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>14</th>
          <td>4</td>
          <td>10</td>
          <td>4.5</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>15</th>
          <td>4</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
          <tr>
          <th>16</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>17</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>18</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>19</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>20</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>burr</td>
          <td>light</td>
        </tr>
        <tr>
          <th>21</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>burr</td>
          <td>dark</td>
        </tr>
        <tr>
          <th>22</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>blade</td>
          <td>light</td>
        </tr>
        <tr>
          <th>23</th>
          <td>3.25</td>
          <td>9</td>
          <td>4</td>
          <td>blade</td>
          <td>dark</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>2<sup>(5-1)</sup> Factorial Power</h2>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>Power</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>amount</th>
          <td>96.55%</td>
        </tr>
        <tr>
          <th>grind_size</th>
          <td>96.55%</td>
        </tr>
        <tr>
          <th>brew_time</th>
          <td>96.55%</td>
        </tr>
        <tr>
          <th>grind_type</th>
          <td>99.61%</td>
        </tr>
        <tr>
          <th>beans</th>
          <td>99.61%</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>2<sup>(5-1)</sup> Factorial Power<br>(Interaction Model)</h2>
    <pre>
      <code data-trim data-noescape>
coffee_design = dexpy.factorial.build_factorial(5, 2**(5-1))
coffee_design.columns = ['amount',
                         'grind_size',
                         'brew_time',
                         'grind_type',
                         'beans']
twofi_model = "(" + '+'.join(coffee_design.columns) + ")**2"
fractional_power = dexpy.power.f_power(twofi_model, coffee_design,
                                       2.0, 0.05)
			</code>
		</pre>
  </section>

  <section>
    <h3>2<sup>(5-1)</sup> Factorial Power<br>(Interaction Model)</h3>
    <table style="font-size: 18;">
      <thead>
        <tr>
          <th></th>
          <th>Power</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>amount
          <td>93.67%
        </tr>
        <tr>
          <td>grind_size
          <td>93.67%
        </tr>
        <tr>
          <td>brew_time
          <td>93.67%
        </tr>
        <tr>
          <td>grind_type
          <td>98.91%
        </tr>
        <tr>
          <td>beans
          <td>98.91%
        </tr>
        <tr>
          <td>amount:grind_size
          <td>93.67%
        </tr>
        <tr>
        <td>amount:brew_time
          <td>93.67%
        </tr>
        <tr>
          <td>amount:grind_type
          <td>93.67%
        </tr>
        <tr>
          <td>amount:beans
          <td>93.67%
        </tr>
        <tr>
          <td>grind_size:brew_time
          <td>93.67%
        </tr>
        <tr>
          <td>grind_size:grind_type
          <td>93.67%
        </tr>
        <tr>
          <td>grind_size:beans
          <td>93.67%
        </tr>
        <tr>
          <td>brew_time:grind_type
          <td>93.67%
        </tr>
        <tr>
          <td>brew_time:beans
          <td>93.67%
        </tr>
        <tr>
          <td>grind_type:beans
          <td>98.91%
        </tr>
      </tbody>
    </table>
  </section>
</section>

<section>
  <section data-markdown>
    <textarea data-template>
## Analysis

* [statsmodels](http://statsmodels.sourceforge.net/) has many routines for modeling data
* We will use [Ordinary Least Squares (OLS)](http://statsmodels.sourceforge.net/devel/examples/notebooks/generated/ols.html) to fit
* `statsmodels` typically takes `numpy` arrays for X and y data
* It also has a "formulas" api that accepts a `patsy` formula
    </textarea>
  </section>
</section>

<section>
  <section>
    <h2>Interaction Model</h2>
    <pre>
      <code data-trim data-noescape>
twofi_model = "(" + '+'.join(coffee_design.columns) + ")**2"
lm = statsmodels.formula.api.ols("taste_rating ~" + twofi_model,
                                 data=coffee_design).fit()
print(lm.summary2())
      </code>
    </pre>
  </section>
  <section>
    <pre>
                   Results: Ordinary least squares
=====================================================================
Model:                OLS               Adj. R-squared:      <span class="fragment highlight-blue">0.904</span>
Dependent Variable:   taste_rating      AIC:                 54.9989
Date:                 2017-06-02 23:07  BIC:                 73.8478
No. Observations:     24                Log-Likelihood:      -11.499
Df Model:             15                F-statistic:         15.52
Df Residuals:         8                 Prob (F-statistic):  <span class="fragment highlight-blue">0.000271</span>
R-squared:            <span class="fragment highlight-blue">0.967</span>             Scale:               0.45796
---------------------------------------------------------------------
                       Coef.  Std.Err.    t    P>|t|   [0.025  0.975]
---------------------------------------------------------------------
Intercept              5.0318   0.1381 36.4265 0.0000  4.7133  5.3504
amount                 0.9731   0.1692  5.7521 0.0004  0.5830  1.3633
grind_size             0.0021   0.1692  0.0127 <span class="fragment highlight-red">0.9902</span> -0.3880  0.3923
brew_time              1.2061   0.1692  7.1293 0.0001  0.8160  1.5963
grind_type            -0.0974   0.1381 -0.7053 <span class="fragment highlight-red">0.5006</span> -0.4160  0.2211
beans                  0.5774   0.1381  4.1802 0.0031  0.2589  0.8960
amount:grind_size      0.0859   0.1692  0.5074 <span class="fragment highlight-red">0.6255</span> -0.3043  0.4760
amount:brew_time      -0.0824   0.1692 -0.4871 <span class="fragment highlight-red">0.6393</span> -0.4725  0.3077
amount:grind_type     -0.1885   0.1692 -1.1140 <span class="fragment highlight-red">0.2976</span> -0.5786  0.2017
amount:beans          -1.4820   0.1692 -8.7600 0.0000 -1.8722 -1.0919
grind_size:brew_time   0.3961   0.1692  2.3413 0.0473  0.0060  0.7862
grind_size:grind_type -0.6927   0.1692 -4.0946 0.0035 -1.0829 -0.3026
grind_size:beans       0.2202   0.1692  1.3017 <span class="fragment highlight-red">0.2292</span> -0.1699  0.6104
brew_time:grind_type   0.8850   0.1692  5.2312 0.0008  0.4949  1.2752
brew_time:beans        0.1727   0.1692  1.0209 <span class="fragment highlight-red">0.3372</span> -0.2174  0.5629
grind_type:beans       0.0360   0.1381  0.2607 <span class="fragment highlight-red">0.8009</span> -0.2825  0.3546
=====================================================================
    </pre>
  </section>
</section>

<section>
  <section>
    <h2>Reduced Model</h2>
    <pre>
      <code data-trim data-noescape class="py">
reduced_model = "amount + grind_size + brew_time + "
                "grind_type + beans + "
                "amount:beans + grind_size:brew_time + "
                "grind_size:grind_type"

lm = statsmodels.formula.api.ols("taste_rating ~" + reduced_model,
                                  data=coffee_design).fit()
print(lm.summary2())
      </code>
    </pre>
  </section>

  <section>
    <pre>
                   Results: Ordinary least squares
=====================================================================
Model:                OLS               Adj. R-squared:      <span class="fragment highlight-blue">0.746</span>
Dependent Variable:   taste_rating      AIC:                 79.5691
Date:                 2017-06-02 23:07  BIC:                 90.1715
No. Observations:     24                Log-Likelihood:      -30.785
Df Model:             8                 F-statistic:         9.438
Df Residuals:         15                Prob (F-statistic):  <span class="fragment highlight-blue">0.000123</span>
R-squared:            <span class="fragment highlight-blue">0.834</span>             Scale:               1.2184
---------------------------------------------------------------------
                       Coef.  Std.Err.    t    P>|t|   [0.025  0.975]
---------------------------------------------------------------------
Intercept              5.0318   0.2253 22.3328 0.0000  4.5516  5.5121
amount                 0.9731   0.2759  3.5266 0.0031  0.3850  1.5613
grind_size             0.0021   0.2759  0.0078 0.9939 -0.5860  0.5903
brew_time              1.2061   0.2759  4.3709 0.0005  0.6180  1.7943
grind_type            -0.0974   0.2253 -0.4324 0.6716 -0.5777  0.3828
beans                  0.5774   0.2253  2.5628 0.0216  0.0972  1.0577
<span class="fragment highlight-green">amount:beans          -1.4820   0.2759 -5.3707 0.0001 -2.0702 -0.8939</span>
<span class="fragment highlight-green">grind_size:brew_time   0.3961   0.2759  1.4354 0.1717 -0.1921  0.9843</span>
grind_size:grind_type -0.6927   0.2759 -2.5103 0.0240 -1.2809 -0.1046
=====================================================================
    </pre>
  </section>
</section>

<section>
  <section>
    <h1>Prediction</h1>
  </section>
  <section>
    <h2>Actual vs Predicted</h2>
    <p>
      If we take the experiment data from the design and use our new model to fit that data, then plot it against
      the observed values we can get an idea for how well our model predicts.
      Points above the 45 degree line are
      overpredicting for that combination of inputs. Points below the line predict a lower taste rating than
      we actually measured during the experiment.
    </p>

  </section>

  <section>
    <h2>Actual vs Predicted</h2>
    <pre>
      <code>
actual_predicted = pd.DataFrame(
  {
    'actual': coffee_design['taste_rating'],
    'predicted': lm.fittedvalues
  }, index=np.arange(len(coffee_design['taste_rating'])))
fg = sns.FacetGrid(actual_predicted, size=5)
fg.map(plt.scatter, 'actual', 'predicted')
      </code>
    </pre>
  </section>
  <section>
    <img src="img/actual_vs_predicted.svg">
  </section>

  <section>
    <h2>Interaction Plots</h2>
    <p>
      Plotting the prediction for two factors at once shows how they interact with each other.
    </p>
  </section>

  <section>
    <h2>Interaction Plots</h2>
    <h3>Grind Size vs Brew Time</h3>
    <pre>
      <code>
pred_points = pd.DataFrame(1, columns = coffee_design.columns,
                              index=np.arange(4))
pred_points.loc[1,'grind_size'] = -1
pred_points.loc[3,'grind_size'] = -1
pred_points.loc[2,'brew_time'] = -1
pred_points.loc[3,'brew_time'] = -1
pred_points['taste_rating'] = lm.predict(pred_points)
pred_points = coded_to_actual(pred_points, actual_lows, actual_highs)

fg = sns.factorplot('grind_size',
                    'taste_rating',
                    hue='brew_time', kind='point', data=pred_points)
      </code>
    </pre>
  </section>

  <section>
    <img src="img/grindsize_vs_brewtime.svg">
    <p>
      In this graph you can see that at the low brew time the larger grind size
      results in a poor taste rating, likely because the coffee is too weak.
    </p>
  </section>

  <section>
    <h2>Interaction Plots</h2>
    <h3>Amount vs Bean Type</h3>
    <pre>
      <code>
pred_points = pd.DataFrame(1, columns = coffee_design.columns,
                              index=np.arange(4))
pred_points.loc[1,'amount'] = -1
pred_points.loc[3,'amount'] = -1
pred_points.loc[2,'beans'] = -1
pred_points.loc[3,'beans'] = -1
pred_points['taste_rating'] = lm.predict(pred_points)
pred_points = coded_to_actual(pred_points, actual_lows, actual_highs)

fg = sns.factorplot('amount', 'taste_rating', hue='beans',
                    kind='point',
                    palette={'dark': 'maroon', 'light': 'peru'},
                    data=pred_points)
      </code>
    </pre>
  </section>


  <section>
    <img src="img/amount_vs_beans.svg">
    <p>
      This graph contains the prediction with the highest taste rating, 7.72.
      However, if you look at the dark bean line there is a point where we can
      get a rating of 6.93 with 2.5oz of grounds.
    </p>
  </section>

  <section>
    <h2>Interaction Plots</h2>
    <h3>Amount vs Bean Type</h3>
    <table>
      <thead>
        <tr>
          <th>amount</th>
          <th>grind_size</th>
          <th>brew_time</th>
          <th>grind_type</th>
          <th>beans</th>
          <th>taste_rating</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>2.5</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>light</td>
          <td>2.81345</td>
        </tr>
        <tr>
          <td>4</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>dark</td>
          <td>5.91462</td>
        </tr>
        <tr>
          <td>2.5</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>dark</td>
          <td class="fragment highlight-green">6.93237</td>
        </tr>
        <tr>
          <td>4</td>
          <td>10</td>
          <td>4.5</td>
          <td>blade</td>
          <td>light</td>
          <td class="fragment highlight-green">7.7238</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

<section>
  <section data-markdown>
    <textarea data-template>
# The End

* We were able to build an efficient fractional factorial in Python.
* Using that factorial design, we executed the experiment and modeled the
results using statsmodels.
* Using predictons from the statsmodels fit, we were able to find a
combination of inputs that resulted in a better tasting (and cheaper!) coffee.
    </textarea>
  </section>

  <section data-markdown>
    <textarea data-template>
# The End

* These slides can be found at https://hpanderson.github.io/dexpy-bdt
* The jupyter notebook they are based on can be found on my github: https://github.com/hpanderson/dexpy-bdt
* You can reach me at: <hank@statease.com>
* The `dexpy` docs are at: https://statease.github.io/dexpy/
* `dexpy` is only at version 0.1, we plan on greatly expanding the design and analysis capabilities
    </textarea>
  </section>
</section>

<section>
  <img src="img/coffee_maker.jpg">
</section>

</div>
</div>
<script src="reveal.js/lib/js/head.min.js"></script>
<script src="reveal.js/js/reveal.js"></script>
<script>
	Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// Optional reveal.js plugins
			dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true }
			]
	});
</script>
</body>
</html>
